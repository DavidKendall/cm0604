<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE document PUBLIC "-//APACHE//DTD Documentation V2.0//EN" "http://forrest.apache.org/dtd/document-v20.dtd">
<document> 
  <header> 
    <title>Exercises 1</title> 
  </header> 
  <body> 
<section id="ex01">
<title>Exercises 1</title>

<p>
<strong>Objectives</strong>
</p>
<ul>
<li>Take first steps with SPIN and PROMELA in modelling and analysing
some simple concurrent systems</li>
<li>Test understanding of basic PROMELA constructs</li>
</ul> 

<p>
<strong>Configuring the environment</strong>
</p>

<p>
In order to complete the work in these labs, you will need to ensure
that the verification tools have been correctly configured for your
Linux environment.
</p>

<p>
You can check this by entering the command <code>ispin &amp;</code> in
a command terminal, e.g.<br/><br/>
<code>
student@c123456:~$ ispin &amp;
</code>
</p>


<p>
Note that <code>student@c123456:~$</code> is a <em>prompt</em>
provided by the OS.  The command that you enter is <code>ispin
&amp;</code>. In future examples, the prompt will be abbreviated to
<code>$</code>.
</p>

<p>
If the <code>ispin</code> program does not start then your verification
environment needs to be configured. Please ask your lab tutor for help 
with this.
</p>


<p>
You'll be working initially with the example models that are
distributed with the Spin tool.
Use your browser to download the <a href="http://hesabu.net/cm0604/SpinExamples.tgz">example models</a> then 
execute the following commands to unpack them:
</p>

<source>
<code>
$ cd
$ tar zxvf ~/Downloads/SpinExamples.tgz
</code>
</source>

<p>
The <code>leader.pml</code> example required for the introductory session
can be found in <code>SpinExamples</code>.
</p>


<p>
<strong>First steps</strong><br/> 
Work through the official SPIN <a
href="http://spinroot.com/spin/Man/GettingStarted.html">Getting
Started</a> introduction. Then complete the exercises below.
</p>

<p>
<strong>Exercises</strong>
</p>

<ol>
<li>
Consider the following program then answer the questions below.

<source>
<code>
1	proctype A(chan c) {
2	  c!3
3	}
4
5	proctype B(chan d) {
6	  byte x,y,z;
7	
8	  d?x
9	}
10
11	init {
12	  chan channel = [0] of {byte};
13
14	  atomic {run A(channel); run B(channel)}
15	}
</code>
</source>

<ol>
<li> Is this program syntactically correct? If it is, what does it do?
   Given that the name of the channel in line 2 is "c" and the name of the
   channel in line 8 is "d", say whether process A will succeed in 
   communicating with process B. Explain your answer. Assume that you change
   line 5 to
     <code class="emph">proctype B(chan c) {</code>
   will this affect the behaviour of the program? Explain your answer.
</li>    
<li>
Does it matter that there are 3 variables declared at line 6?
</li>
<li>
If we change line 2 to <code class="emph">c!3,4,5</code> and line 8 to <code class="emph">d?x,y,z</code>
   is the program still correct?
</li>
<li> Assume we change line 2 to
     <code class="emph">c!3,4,5</code>
   and line 12 to
   <code class="emph">chan channel = [3] of {byte}</code>
   is the program correct now?
</li>
<li> If we change line 2 to
     <code class="emph">c!3,4,5</code>
   and line 12 to
     <code class="emph">chan channel = [0] of {byte, byte, byte}</code>
   is the program correct now? Explain your answers to 1 (d) and 1 (e).
</li>
</ol>
</li>

<li> Are the following programs (a and b) syntactically correct? If yes, 
  how do they behave? Suggest how they can be improved by the use of
  mtype declarations.
<ol>
<li>
<source>
<code>
proctype A(chan c) {
  c!3(4);
  c!4(5)    
}

proctype B(chan c) {
  byte x,y,z;

  c?x(z);
  c?y(z)
}

init {
  chan channel = [1] of {byte, byte};

  atomic {run A(channel); run B(channel)}
}
</code>
</source>
</li>

<li>
<source>
<code>
proctype A(chan c) {
  c!3(4,5);
  c!4(5,6)    
}

proctype B(chan c) {
  byte x,y,z;

  c?x(y,z);
  c?y(x,z)
}

init {
  chan channel = [1] of {byte, byte, byte};

  atomic {run A(channel); run B(channel)}
}
</code>
</source>
</li>
</ol>
</li>

<li>
Consider the following program then answer the questions below.
<source>
<code>
1	proctype A(chan c) {
2	  c!3;
3	  c!4    
4	}
5
6	proctype B(chan c) {
7	  byte x,y,z;
8
9	  c?x;
10	  c?y
11	}
12
13	init {
14	  chan channel = [0] of {byte};
15
16	  atomic {run A(channel); run B(channel)}
17	}
</code>
</source>

<ol>
<li>
 Is it possible for line 3 to be executed before line 9? Explain your
   answer.</li>
<li> Assume we change line 14 to
     <code class="emph">chan channel = [1] of {byte}</code>
   now is it possible for line 3 to be executed before line 9? Explain your
   answer.
</li>
</ol>
</li>

<li> Consider the following program then answer the questions below.
<source>
<code> 
1	#define true 1
2	#define false 0
3
4	bool sentmsg2 = false;
5
6	proctype A(chan c) {
7	  c!3;
8	  c!4;
9	  sentmsg2 = true    
10	}
11
12	proctype B(chan c) {
13	  byte x,y,z;
14
15	  assert (!sentmsg2); 
16	  c?x;
17	  c?y
18	}
19
20	init {
21	  chan channel = [2] of {byte};
22
23	  atomic {run A(channel); run B(channel)}
24	}
</code>
</source>

<ol>
<li> Explain how this program allows us to check that it is not possible
   for process A to send its second message (i.e. to execute line 8) before
   process B has received the first message (i.e. has executed line 16).</li>

<li> Use ispin to check the assertion. Explain the answer.</li>

<li> Assume we change line 21 to
     <code class="emph">chan channel = [1] of {byte};</code>
   Does this change the behaviour of the program? Use ispin to check
   your conclusion. Explain the answer.</li>

<li> Try to reach the same conclusions by using simulation rather than 
   verification. (i.e. Use "Simulate" with a variety of seed values instead
   of using "Verify"). What does your experience suggest to you about the
   pros and cons of simulation/verification?</li>
</ol>
</li>

<li> Attempt to verify the following program. What does the result tell
   you about the granularity of execution of Promela's assignment statement? 
   What possible result could a finer granularity lead to? 

<source>
<code>
#define false 0
#define true 1 

byte x = 0;
bool Adone = false;
bool Bdone = false;

proctype A() {
  x = x + 1;
  Adone = true
}

proctype B() {
  x = x + 1;
  Bdone = true
}

init {
  atomic {run A(); run B()};
  Adone; Bdone;
  assert (x == 2)
}
</code>
</source>
</li>

<li>Consider now the following program. Attempt to verify it. Explain the
   answer. 
<source>
<code>
#define false 0
#define true 1 

byte x = 0;
bool Adone = false;
bool Bdone = false;

proctype A() {
  byte v = 0;

  v = x;
  x = v + 1;
  Adone = true
}

proctype B() {
  byte v = 0;

  v = x;
  x = v + 1; 
  Bdone = true
}

init {
  atomic {run A(); run B()};
  Adone; Bdone;
  assert (x == 2)
}
</code>
</source>
</li>

<li> What difference does it make to the program from 6) if we replace
     <code class="emph">v = x; x = v + 1</code>
   by
     <code class="emph">atomic {v + x; x = v + 1}</code>? Explain your answer.
</li>
</ol>
</section>
</body>
</document>
